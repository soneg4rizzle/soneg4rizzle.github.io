---
title: Cookie, Session, JWT
categories: [CS, Network]
tags: [Web, Cookie, Session, JWT]
image:
  path: /assets/post/2025/CS/Web/CookieSessionJWT.jpg
  alt: What is Cookie·Session·JWT ?
published: true
---

안녕하세요. 오늘은 쿠키(Cookie), 세션(Session), JWT(Json Web Token)에 대해서 알아보겠습니다.
쿠키, 세션, JWT는 웹 애플리케이션에서 사용자의 상태를 유지하거나 인증을 관리하는 중요한 기술입니다.
모바일 애플리케이션(네이티브 앱)의 경우에는 브라우저를 사용하지 않기 때문에 쿠키 동작이 수행되지 않습니다.
때문에, 모바일에서는 세션보다 토큰(JWT, OAuth)을 이용하여 사용자 인증을 수행하는 경우가 많습니다.

굳이 따지자면 웹/앱의 차이보다는 인증 정보를 세션(데이터베이스·저장소)에서 관리할지 암호화한 토큰에 넣어 관리할지의 차이로 볼 수 있을 것 같습니다. 그럼 사용자 인증에 사용되는 쿠키, 세션이 무엇일까요?

---

### 1. Cookie, Session
쿠키와 세션을 이해하기 위해서는 먼저 HTTP의 특징을 알아야하는데요.
기본적으로 HTTP 프로토콜은 "connectionless, stateless" 2가지 특성을 가지고 있습니다.
내용을 요약하면 아래와 같습니다.

```
1. 비연결 프로토콜 (Connectionless)
  ㄴ 실제로 요청을 주고받을 때만 연결을 유지하고 요청/응답 후에는 TCP/IP 연결을 종료하는 특징
  ㄴ HTTP/1.1 부터는 keep-alive 옵션을 기본값으로 설정하여 연결을 바로 종료되지 않도록 함

2. 무상태 프로토콜 (Stateless)
  ㄴ 통신(요청/응답)이 끝나면 상태를 유지하지 않는 특징
  ㄴ 연결을 끊는 순간 클라이언트/서버의 통신이 끝나며 상태 정보를 유지하지 않는 특성을 가짐
      ㄴ 쿠키/세션은 위 두 가지 특징을 해결하기 위해 사용

```

JSP 환경에서 쇼핑몰과 같은 웹 애플리케이션을 개발해보신 분들이라면 "JSESSIONID" 라는 값을 보신적이 있으실텐데요.
이 값은 서블릿 컨테이너에서 생성하는 쿠키로 아파치 톰캣(WAS)에서 생성하여 사용자 식별을 위해 클라이언트 측으로 전달하는 쿠키의 키(Key) 값에 해당합니다. 사용자가 최초에 아이디/패스워드를 입력하여 서버 측에 로그인을 요청하면 서버에서는 해당 아이디/패스워드 정보와 일치하는 정보가 데이터베이스에 존재하는지 확인하고 일치하는 정보가 있다면 클라이언트 측에 "Key:Value" 형태의 쿠키 값을 전달합니다.

```http
Set-Cookie: <cookie-name>=<cookie-value>
```

HTTP 프로토콜은 무상태/무연결 특성을 가지기 때문에 이러한 문제를 해결하기 위하여 쿠키/세션을 사용하는 것이죠.
클라이언트는 이후 서버에 권한이 필요한 어떠한 요청을 할 때마다 서버에서 발급받은 쿠키 정보를 HTTP 요청 헤더에 함께 전송하여 자신이 누구인지에 대한 정보를 서버 측에 전달합니다. 서버는 이를 통해 요청자의 신원을 확인하고 그에 걸맞는 기능을 사용할 수 있도록 권한을 제공(인가)해 주는 것이죠.

지금까지 설명드린 일련의 과정들이 바로 아래의 이미지와 같습니다.

<img src="/assets/post/2025/CS/Web/CookieSessionJWT/CookieSessionWork.png" alt='' width=1300px>

만약 쿠키 값에 중요정보가 노출되거나 유추하기 쉬운 값으로 설정되어 있다면 악의적인 의도를 가진 공격자에게 탈취당해 공격당할 위험성이 있는데요. 이러한 공격을 "세션 하이재킹" 이라고 합니다. 타인의 쿠키(Session ID) 값을 탈취할 수 있다면 해당 값을 통해 자신이 타인인 것처럼 위장하여 행동하는 것이 가능해집니다. 서버 측에서는 클라이언트에게 발급받은 쿠키를 통해 해당 사용자가 누구인지를 식별하기 때문에 다른 사용자가 동일한 쿠키값을 사용해도 이를 알아차릴 수 없는 것이죠.

물론 IP/MAC 주소 검증과 같은 추가적인 보안 장치를 통해 대응하는 방법도 있지만 앞서 말씀드린 이유로 세션 탈취는 매우 위험합니다. 때문에 이러한 취약점을 예방하기 위해 서버 측에서는 쿠키 값을 설정할 때 탈취가 쉽지 않도록 긴 문자열과 추측하기 어려운 값을 조합하여 발급합니다. 쿠키 값은 클라이언트 측에서 쉽게 조작이 가능하기 때문에 일반적으로 인증이 필요한 기능의 경우에는 서버 측의 세션을 활용합니다. (세션을 사용하는 경우에는 실제 정보를 쿠키에 담는 것이 아니라 "Session ID"라는 것을 만들어 클라이언트 쪽에서 이를 서버 측에 전달하는 방식으로 사용하고 있습니다.) 

쿠키/세션은 HTTP 프로토콜의 특성을 살리면서도 클라이언트/서버 간의 통신이 원활하도록 하는데 많은 도움을 주는데요.
장점도 있지만 단점 또한 명확합니다.

```
1. 쿠키
    (장점)
      ㄴ 클라이언트(로컬) 측에 저장되므로 서버 측 리소스를 사용하지 않음
      ㄴ 만료 시간 설정을 통해 사용자가 브라우저를 종료한 후에도 일정 기간 유지 가능

    (단점)
      ㄴ 클라이언트 측에 저장되기 때문에 보안적으로 취약 (민감정보 탈취 위험)
      ㄴ 저장할 수 있는 데이터 용량에 제한 (약 4KB)

2. 세션
    (장점)
      ㄴ 서버 측에 데이터를 저장하기 때문에 안전함
      ㄴ 서버 측에 데이터를 저장하므로 상대적으로 많은 데이터 저장이 가능함
      ㄴ 만료시간 설정을 통해 리소스 확보 및 타인의 세션 재사용 등으로부터 안전

    (단점)
      ㄴ 세션 정보는 서버에 저장되기 때문에 대규모 서비스의 경우 서버에 부하 발생
      ㄴ 세션 ID 탈취 시 공격자가 사용자(희생자) 계정 접근 및 사용 가능
```

---

### 2. JWT(Json Web Token)
JWT(Json Web Token)은 JSON 형식으로 정보를 안전하게 전송하기 위한 개방형 표준(RFC 7519) 입니다.

전통적인 세션 기반 인증 방식에서는 서버 측에 사용자의 세션 정보를 저장해야 하기 때문에 서버의 메모리 사용량이 많았고 이에 따라 부하도 커졌습니다. 또한, 분산된 서버 환경에서는 여러 서버 간에 세션 정보를 공유해야 하는데 세션 정보를 공유하고 일관성(Consistency)을 유지하기 어려운 측면이 존재했습니다.

JWT는 서버에 상태를 저장할 필요없이 토큰 자체에 사용자 정보를 담고 있습니다. 때문에 서버는 JWT만 확인하면 사용자의 인증 상태를 파악할 수 있습니다. 클라이언트 측에서는 발급받은 JWT를 관리하고 서버 측에서는 토큰 발급과 토큰의 유효성만 확인하면 되기 때문에 부하가 훨씬 감소한 것이죠.

```
JWT(Json Web Token)
  (장점)
    ㄴ 1. 로컬(클라이언트)에 값을 저장하므로 서버의 영향을 받지 않음
    ㄴ 2. 공개키/개인키(비밀키)를 통해 서명되므로 상대적 안전함
    ㄴ 3. JSON 형식으로 구성되어 다양한 플랫폼(웹, 모바일, ...)에서 사용 가능

  (단점)
    ㄴ 1. JWT가 클라이언트 측에 저장되므로 토큰 탈취 시 공격자가 활용 가능
    ㄴ 2. JWT는 헤더, 페이로드, 서명으로 구성되어 세션/쿠키에 비해 상대적으로 크기가 큼
    ㄴ 3. 세션 방식에서는 서버가 세션을 강제로 종료할 수 있지만
          JWT는 클라이언트 측에서 보관되고 있기 때문에 JWT가 만료되지 않는 한 계속 유효함(보안 문제)
```

JWT는 아래 3가지 요소로 구성됩니다.
```
<헤더>.<페이로드>.<서명>

1. 헤더(Header): 토큰의 타입(JWT)과 사용하는 알고리즘(예: HMAC, SHA256, RSA 등)을 명시합니다. 
2. 페이로드(Payload): 실제 전송할 데이터를 포함합니다. 주로 사용자 정보나 권한 정보를 담고 있습니다. 
3. 서명(Signature): 헤더와 페이로드를 비밀 키 또는 공개/비공개 키 쌍으로 서명하여 데이터가 변조되지 않았음을 검증할 수 있게 합니다.
```

<img src='/assets/post/2025/CS/Web/CookieSessionJWT/HowJWTWorks.jpg' alt='' width=1300px>

위 그림과 같이 사용자가 로그인을 시도하면 서버에서는 사용자 정보를 확인(검증)한 뒤에 JWT 토큰을 생성·발급하여 전달합니다.
이후 클라이언트가 웹 브라우저 혹은 모바일 앱 등에서 서버(ex; API)로 요청할 때 JWT 토큰을 헤더에 담아 요청합니다.
서버에서는 JWT 토큰에 포함된 서명(Signature)을 헤더에 명시된 알고리즘을 통해 검증하고 이에 따라 응답을 전달하게 됩니다.

만약 클라이언트가 발급받은 JWT 토큰(Access Token)이 만료되었다면 "Refresh Token"을 헤더에 담아서 다시 "Access Token" 발급을 요청하는데요. 서버 측에서는 클라이언트로부터 전달받은 "Refresh Token"에 문제가 없다면 "Access Token"을 재발급하여 클라이언트에게 전달해줍니다.

```
Refresh Token : Access Token 만료 시 재발급을 위한 토큰으로 사용
Access Token : 실질적으로 API 사용에 사용되는 토큰 (해당 토큰으로 인가 여부 확인)
```

서버에서는 클라이언트로부터 전달받은 JWT 토큰의 유효성을 다음과 같이 검증합니다.

#### 헤더 검증
서버는 JWT 토큰의 헤더에 정의된 알고리즘(alg)과 타입(typ)을 확인
이 때, 알고리즘은 서버에 지정된 알고리즘과 동일해야함

#### 시그니처 검증
서버는 JWT 토큰의 헤더에서 확인한 알고리즘을 사용하여 서버의 비밀키(Private Key)와 페이로드를 기반으로 새로운 서명을 생성
생성된 새로운 서명과 클라이언트로부터 전달받은 JWT 토큰의 서명(Signature)를 비교하여 동일한 경우 유효성 검증 통과

#### 페이로드 검증
서버는 JWT 토큰의 페이로드로부터 토큰의 발급·만료시간 및 사용자 정보 등을 확인
해당 정보는 서버에 저장된 사용자 정보와 일치해야함

---

JWT 토큰은 암호화한 것이 아니라 base64 인코딩한 것이기 때문에 디코딩을 통해 내용을 확인할 수 있습니다.
따라서, 정보가 저장되는 페이로드 부분에 중요·민감정보를 저장해서는 안 됩니다.
또한 헤더의 알고리즘을 "None"으로 변조하여 인증을 우회하거나 서버 측의 비밀키를 전수공격을 통해 알아내는 방법 또한 존재합니다. 추후 포스팅에서는 JWT 토큰을 우회와 관련된 여러 취약점들과 OAuth 토큰에 대해서도 다뤄보도록 하겠습니다.

---

### Reference
이 포스트는 아래 게시글의 정보 및 이미지가 사용되었습니다.
1. [Cookie and Session](https://medium.com/@alysachan830/cookie-and-session-ii-how-session-works-in-express-session-7e08d102deb8)
2. [JSON Web Token](https://blog.bytebytego.com/p/ep69-explaining-json-web-token-jwt)

---

<h2 style="text-align: center;" data-ke-size="size26"><b>END</b></h2>
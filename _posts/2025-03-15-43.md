---
title: (Android)[Frida] Uncrackable-Level3 PoC
categories: [System Security Vulnerability, Mobile Application]
tags: [Uncrackable-Level3, Frida]
image:
  path: /assets/post/2025/SSV/Android/41/thumb.png
  alt: Uncrackable-Level3
published: false
---

언크래커블 실습 레츠고~

## (Practice) Uncrackable Level 3

앱 실행 시 `Rooting or tampering detected.` 알림창이 발생합니다.  
디컴파일 해서 소스코드를 확인해봅시다. 

<img src='assets/post/2025/SSV/Android/43/1.png' width=1300 alt=''>

---

### 정보수집

1. 앱 실행 시 onCreate 함수에서 `verifyLibs`, `init(xorkey.getBytes())` 함수가 실행되고 있습니다.    
2. `AsyncTask` 에서는 앱의 디버깅 모드 활성화(`AndroidManifest > android:debuggable="true"`) 여부를 검증하고 있습니다.  
3. 조건문에서는 아래 3가지 경우를 검증하고 있습니다.    
    - 3-1. 루팅 탐지 (checkRoot1, checkRoot2, checkRoot3)  
    - 3-2. 디버깅 가능 여부 탐지 (IntegrityCheck.isDebuggable(getApplicationContext()))  
    - 3-3. 무결성 변조 여부 탐지 (tampered)

<img src='assets/post/2025/SSV/Android/43/2.png' width=1300 alt=''>

---

개략적으로 코드를 분석한 이후에 [프리다 스크립트](https://soneg4rizzle.github.io/posts/41/#%EB%A3%A8%ED%8C%85-%ED%83%90%EC%A7%80-%EC%9A%B0%ED%9A%8C-%EC%BD%94%EB%93%9C)를 실행해보면 아래와 같은 에러 메시지가 발생하는데요. `backtrace` 출력 정보를 통해 어느 구간에서 오류가 발생하였는지 확인할 수 있습니다.

<img src='assets/post/2025/SSV/Android/43/3.png' width=1300 alt=''>

---

기드라 혹은 아이다를 활용해서 `goodbye()` 함수가 실행되는 구간으로 넘어가보겠습니다. 
`FUN_001030d0` 함수 내부를 살펴보면 `goodbye()` 를 발견할 수 있는데요. 로직을 분석해보면 아래와 같습니다.

1. `fopen` 함수로 `/proc/self/maps` 파일 오픈  
    - 1-1. 정상적으로 열린 경우  
        - 해당 파일에서 `frida`, `xposed` 문자열 발견되면 `Tampering detected! Terminating...` 로그 출력한 뒤 `goodbye()` 함수 실행하여 프로세스 종료  
    - 1-2. 정상적으로 열리지 않은 경우  
        - `"Error opening /proc/self/maps! Terminating..."` 로그 출력한 뒤 `goodbye()` 함수 실행하여 프로세스 종료  
2. 반복문(while) 밖으로 나가게 되는 순간 goodbye() 함수가 실행되어 종료됨  
3. 따라서, `fopen, strstr, fgets` 함수를 후킹하여 덤프 값으로 덮어씌우면 우회 가능  

<img src='assets/post/2025/SSV/Android/43/4.png' width=1300 alt=''>

---

필자는 문자열 비교 함수 `strstr` 의 인자 값을 변조하여 우회를 시도해보았습니다.

```js
send("[*] hook hook hook !");

Interceptor.attach(Module.findExportByName(null, "strstr"), {
    onEnter: function(args) {
        console.warn('\n[*] strstr function has been called !');
        var args0 = Memory.readUtf8String(ptr(args[0]));
        var args1 = Memory.readUtf8String(ptr(args[1]));
        
        if (args1 == "frida") {
            console.log('\targs0 => ', args0);
            console.log('\targs1 => ', args1);

            Memory.writeUtf8String(args[1], "dumpdumpdumpdump");
        }
    }
})
```

---

위 스크립트를 실행하면 아래와 같은 결과를 얻을 수 있는데요. `/proc/self/maps` 파일에서 `frida` 문자열이 발견되면 바로 프로세스(앱)가 종료되고 있습니다. 이는 앞에서 분석했듯이 "frida/xposed" 문자열이 발견되면 `goodbye()` 함수가 실행되기 때문입니다.  

추가로, `strstr(acStack_240,"frida")`의 "frida" 문자열을 다른 값으로 덮어씌우는 과정에서 `Error: access violation accessing 0x746ce6c4da ...` 오류가 발생하는데 이는 `Memory.protect(address, size, protection)` 코드를 통해 특정 메모리 주소에 대한 RWX 권한을 재설정하여 해결할 수 있습니다.

참고 - https://naro-security.tistory.com/26

<img src='assets/post/2025/SSV/Android/43/5.png' width=1300 alt=''>

---

수정된 스크립트는 아래와 같습니다.

```js
send("[*] hook hook hook !");

Interceptor.attach(Module.findExportByName(null, "strstr"), {
    onEnter: function(args) {
        console.warn('\n[*] strstr function has been called !');
        var args0 = Memory.readUtf8String(ptr(args[0]));
        var args1 = Memory.readUtf8String(ptr(args[1]));
        
        // 특정 메모리 주소의 RWX 권한 설정 (rw-, r-x, -wx, etc.)
        Memory.protect(ptr(args[1]), 64, "rwx");
        if (args1 == "frida") {
            console.log('\targs0 => ', args0);
            console.log('\targs1 => ', args1);

            Memory.writeUtf8String(args[1], "dumpdumpdumpdump");
        }
    }
})
```
---

짜잔! 이제 프리다를 이용해서 정상적으로 앱 실행이 가능합니다. 

<img src='assets/post/2025/SSV/Android/43/6.png' width=1300 alt=''>

앞선 과정에서 이미 JADX로 자바 코드를 확인해봤는데요. `Rooting or tampering detected` 메시지가 발생하였으니 `verifyLibs(), init(...), Debug.isDebuggerConnected()` 함수는 별도 우회과정이 필요하지 않습니다.

~~우회할 필요는 없지만 궁금해서 확인해보니 무결성 탐지와 디버깅 탐지 로직이었습니다~~

이제 메인 액티비티로 접근하기 위해서는 아래 코드에서 검증하는 구간을 우회하면 됩니다.  

```java
if (RootDetection.checkRoot1() || RootDetection.checkRoot2() || RootDetection.checkRoot3() || IntegrityCheck.isDebuggable(getApplicationContext()) || tampered != 0)
```

---

여기서 우회가 필요한 함수는 `checkRoot1()` 1가지인데요.  
`checkRoot2`는 Build.TAGS 값이 "release-keys" 이고, `checkRoot3`에서 탐지하는 경로들은 매지스크로 루팅한 단말이기 때문에 존재하지 않았습니다. 그리고 `IntegrityCheck.isDebuggable(getApplicationContext())`도 AndroidManifest 파일에 디버깅 설정이 없었기 때문에 해당사항이 없고 `tampered` 값 또한 앱 리빌드를 하지 않았으므로 무결성이 침해된 바가 없어 탐지될 일이 없습니다.  

기존에 작성한 스크립트에서 `checkRoot1()` 의 탐지 로직을 우회한 스크립트는 아래와 같습니다. level1, level2와 동일하게 "java.io.File(args0, args1)" 클래스의 인스턴스가 생성될 때 인자 값을 변조하는 방식으로 우회했습니다.

```js
send("[*] hook hook hook !");
Java.perform(function () {
    console.log();

    var File = Java.use('java.io.File');
    File.$init.overload('java.lang.String', 'java.lang.String').implementation = function (str, su) {
        var stackTrace = Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Exception").$new());

        if (stackTrace.includes("sg.vantagepoint.util.RootDetection.checkRoot1")) {
            console.warn('File.$init(str, "su") in sg.vantagepoint.util.RootDetection.checkRoot1 has been called !')
            console.log(`\tFile.$init(str, "su") => File.$init(${str}, "su")`);
            return this.$init("dumptrashdumptrash", su);
        }

        return this.$init(str, su);
    }
})

Interceptor.attach(Module.findExportByName(null, "strstr"), {
    onEnter: function(args) {
        var args0 = Memory.readUtf8String(ptr(args[0]));
        var args1 = Memory.readUtf8String(ptr(args[1]));
        
        Memory.protect(ptr(args[1]), 64, "rwx");
        if (args1 == "frida") {
            console.warn('\n[*] strstr function has been called !');
            console.log('\targs0 => ', args0);
            console.log('\targs1 => ', args1);

            Memory.writeUtf8String(args[1], "dumpdumpdumpdump");
        }
    }
})
```

---

스크립트 실행 시 정상적으로 메인 액티비티에 진입이 가능합니다.  
이후 임의의 값을 입력 후 "VERIFY" 버튼을 클릭하면 이전 문제들과 동일하게 `That's not it. Try again` 알림창이 발생합니다. 해당 부분에 대한 코드를 분석해보시죠.

<img src='assets/post/2025/SSV/Android/43/7.png' width=1300 alt=''>

---

`this.check.check_code(obj)` 함수의 실행 결과에 따라서 성공/실패 화면이 출력되는 것을 확인할 수 있는데요. `check_code(obj)` 함수 내부를 살펴보니 네이티브 함수(bar)를 호출하여 사용하고 있습니다. 다시 기드라로 이동해서 `bar` 함수가 어떻게 동작하는지 확인해보겠습니다.

<img src='assets/post/2025/SSV/Android/43/8.png' width=1300 alt=''>

---

기드라에서 `Java_sg_vantagepoint_uncrackable3_CodeCheck_bar` 함수를 살펴보면 `DAT_00115054, DAT_00115038` 값에 따라 코드가 분기되고 있는데요.  

위 변수들에 어떤 값이 들어있는지 확인해보겠습니다.

<img src='assets/post/2025/SSV/Android/43/9.png' width=1300 alt=''>
---

##### `DAT_00115054, DAT_00115038` 값 확인

참고 : https://hackcatml.tistory.com/105

```js

```

## Reference
1. https://mas.owasp.org/crackmes/
2. https://hackcatml.tistory.com/105